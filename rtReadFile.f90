LOGICAL FUNCTION RT_READ_FILE(PATH, IOS, IOERR, RT)
	
	implicit none;
	
	!!! VARIÁVEIS DE ENTRADA
	character(len=*), target, intent(IN) :: PATH;
	
	!!! VARIÁVEIS DE SAÍDA
	integer, intent(INOUT) :: IOS;
	character(len=*), intent(INOUT) :: IOERR;
	type(RAMTXT), intent(OUT) :: RT;
	
	!!! VARIÁVEIS INTERNAS DA FUNÇÃO
	logical :: FILE_EXISTS;
	integer(kind=RT_INT_KIND) :: FILE_SIZE;
	integer :: FID;
	integer(kind=RT_INT_KIND) :: NUM_LINES;
	integer(kind=RT_INT_KIND) :: i, CTR, PREVIDX, CR_OFFSET;
	
	!!! INÍCIO DA FUNÇÃO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
	!!! PRESSUPOR LEITURA INVÁLIDA.
	RT_READ_FILE = .FALSE.;
	
	!!! VERIFICAR SE O ARQUIVO EXISTE
	INQUIRE (FILE=PATH, EXIST=FILE_EXISTS, IOSTAT=IOS, IOMSG=IOERR);
	IF (FILE_EXISTS .EQV. .FALSE.) RETURN; ! ARQUIVO INEXISTENTE
	
	!!! COLETAR TAMANHO DO ARQUIVO
	INQUIRE (FILE=PATH, SIZE=FILE_SIZE, IOSTAT=IOS, IOMSG=IOERR);
	
	IF (IOS .NE. 0) RETURN; ! LEITURA MAL-SUCEDIDA
	
	IF (FILE_SIZE .EQ. 0) THEN ! ARQUIVO VAZIO
		
		IOS = RT_NULLFILE_CODE;
		IOERR = RT_NULLFILE_MSG;
		
	END IF
	
	!!! ABRIR ARQUIVO
	OPEN (  FILE=PATH, NEWUNIT=FID,                                 &
	        ACCESS="STREAM", ACTION="READ", IOSTAT=IOS, IOMSG=IOERR );
	
	IF (IOS .NE. 0) RETURN; ! ERRO AO TENTAR ABRIR ARQUIVO.
	
	!!! ALOCAR MEMÓRIA
	ALLOCATE(character(len=FILE_SIZE) :: RT%STRING, STAT=IOS, ERRMSG=IOERR);
	IF (IOS .NE. 0) THEN
		
		CLOSE (FID);
		RETURN; ! PROBLEMA AO TENTAR ALOCAR MEMÓRIA.
		
	END IF
	
	!!! PASSAR AS ESCRITURAS DO USUÁRIO PARA A MEMÓRIA
	READ (UNIT=FID, IOSTAT=IOS, IOMSG=IOERR) RT%STRING;
	IF (IOS .NE. 0) RETURN; ! ERRO AO TENTAR LEITURA.
	
	!!! FECHAR ARQUIVO.
	CLOSE (UNIT=FID, STATUS="KEEP", IOSTAT=IOS, IOMSG=IOERR);
	IF (IOS .NE. 0) RETURN; ! ERRO AO TENTAR FECHAR ARQUIVO.
	
	!!! COLETAR NÚMERO DE LINHAS
	NUM_LINES = 0;
	DO i=1, FILE_SIZE
		
		IF (RT%STRING(i:i) .EQ. ACHAR(10)) NUM_LINES = NUM_LINES + 1;
		
	END DO
	
	!!! ALOCAR MAPA DE LINHAS
	ALLOCATE(RT%IDX(2, NUM_LINES), STAT=IOS, ERRMSG=IOERR);
	IF (IOS .NE. 0) RETURN; ! ERRO DE ALOCAÇÃO.
	
	!!! MAPEAR INÍCIO E FIM DE CADA LINHA NO ARQUIVO DE TEXTO
	CTR = 0;
	PREVIDX = 1;
	CR_OFFSET = 0;
	DO i=1, FILE_SIZE
		
		IF (RT%STRING(i:i) .EQ. ACHAR(10)) THEN
			
			CTR = CTR + 1;
			
			RT%IDX(1, CTR) = PREVIDX;
			RT%IDX(2, CTR) = i - 1 - CR_OFFSET;
			
			PREVIDX = i + 1;
			
		END IF
		
		! TRATAR CARRIAGE RETURN - OFFSET PROPAGA PARA A PRÓXIMA ITERAÇÃO
		IF (RT%STRING(i:i) .EQ. ACHAR(13)) THEN
			CR_OFFSET = 1;
		ELSE
			CR_OFFSET = 0;
		END IF
		
	END DO
	
	! TRATAR FINAL DE ARQUIVO
	IF (RT%STRING(FILE_SIZE:FILE_SIZE) .NE. ACHAR(10)) THEN
		
		CTR = CTR + 1;
		RT%IDX(1, CTR) = PREVIDX;
		RT%IDX(2, CTR) = FILE_SIZE;
		
	END IF
	
	!!! INICIALIZAR VARIÁVEIS RESTANTES RT
	ALLOCATE (character(len=LEN(PATH)) :: RT%PATH, STAT=IOS, ERRMSG=IOERR);
	IF (IOS .NE. 0) RETURN;
	RT%PATH = PATH;
	
	RT%LAST_LINE_READ = 0;
	
	!!! ATRIBUIR LEITURA BEM-SUCEDIDA.
	RT_READ_FILE = .TRUE.;
	
END FUNCTION RT_READ_FILE
